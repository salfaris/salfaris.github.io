<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.55">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Salman Faris">
<meta name="dcterms.date" content="2024-10-17">

<title>Is Costco fuel cheaper overall given the membership premium? – salman faris</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta name="twitter:title" content="Is Costco fuel cheaper overall given the membership premium? – salman faris">
<meta name="twitter:description" content="">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title"><strong>salman faris</strong></span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">about</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../resources.html"> 
<span class="menu-text">resources</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/salfaris/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/salfaris"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Is Costco fuel cheaper overall given the membership premium?</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">mathematical modelling</div>
                <div class="quarto-category">personal finance</div>
                <div class="quarto-category">pricing</div>
                <div class="quarto-category">car talk</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Salman Faris </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 17, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#modelling-the-problem" id="toc-modelling-the-problem" class="nav-link active" data-scroll-target="#modelling-the-problem">Modelling the problem</a></li>
  <li><a href="#some-actual-numbers" id="toc-some-actual-numbers" class="nav-link" data-scroll-target="#some-actual-numbers">Some actual numbers</a>
  <ul class="collapse">
  <li><a href="#direct-compute" id="toc-direct-compute" class="nav-link" data-scroll-target="#direct-compute">Direct compute</a></li>
  <li><a href="#using-the-p-criterion." id="toc-using-the-p-criterion." class="nav-link" data-scroll-target="#using-the-p-criterion.">Using the <span class="math inline">p^*</span> criterion.</a></li>
  </ul></li>
  <li><a href="#so-is-costco-truly-worth-it" id="toc-so-is-costco-truly-worth-it" class="nav-link" data-scroll-target="#so-is-costco-truly-worth-it">So is Costco truly worth it?</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Today, let’s talk about petrol prices. It is well known that there’s no petrol cheaper than Costco’s with several pence in difference, sometimes up to 5p. The problem is there’s a membership premium to even start purchasing Costco petrol and that Costco tends to be located significantly far away from the city centre.</p>
<p>So this begs the question: if we forget the add-on benefit of being able to shop at Costco with the membership, is it worth it to fuel your car at Costco despite the premium and the distance? That is, from the worst case scenario perspective of “I just want to get out, fill my car and go back home”, is it worth it?</p>
<p>Let’s dive straight into modelling this problem and find the breakeven.</p>
<section id="modelling-the-problem" class="level2">
<h2 class="anchored" data-anchor-id="modelling-the-problem">Modelling the problem</h2>
<p>This is blatantly obvious but remember that getting to the petrol station and back is not free, it costs money on its own. Costco tends to be in the outskirts, so to fill our car there requires a distance <span class="math inline">d^*</span> that is much further than the distance <span class="math inline">d</span> to our nearest petrol station (in my case, is an Esso). But remember the advantage is that the petrol cost <span class="math inline">p^*</span> at Costco is much cheaper compared to the petrol cost <span class="math inline">p</span> at our nearest station. Here, <span class="math inline">d</span> and <span class="math inline">d^*</span> are measured in miles, and <span class="math inline">p</span> and <span class="math inline">p^*</span> are measured in pence/litres. Naturally, <span class="math inline">d</span> and <span class="math inline">d^*</span> are not measured in the Euclidean distance, but rather measured as the sum of distances on the roads taken (think a path integral).</p>
<p>Now fix a fuel economy <span class="math inline">e</span> for the car you are driving. Typically, car makers report this in litres/100km or miles/gallon. I will be thinking of this in terms of litres/miles, and the conversion should be straightforward. With the fuel economy fixed, the total petrol we need to fill to cover the distance alone are</p>
<p><span class="math display">
\begin{align*}
\text{Costco:} &amp;\quad v_{\mathrm{cover}}^{*} = 2{d^*}e, \\
\text{Nearest:} &amp;\quad v_{\mathrm{cover}} = 2de.
\end{align*}
</span></p>
<p>Observe that we slapped a 2 in front since you have to go to the petrol station and back. If you want to be pedantic, this is not really accurate as the route back might be different (shorter/longer) but I think this is a fair enough assumption. After all, I just want an estimation.</p>
<p>Suppose that I want a volume <span class="math inline">V</span> petrol when I reach back home after fuelling regardless of which petrol station I go to, then we want to fill in <span class="math display">
\begin{align*}
\text{Costco:} &amp;\quad V + v_{\mathrm{cover}}^{*}, \\
\text{Nearest:} &amp;\quad V + v_{\mathrm{cover}},
\end{align*}
</span></p>
<p>respectively at the petrol station. This implies that the total cost for filling in petrol is given by</p>
<p><span class="math display">
\begin{align*}
\text{Costco:} &amp;\quad (V + v_{\mathrm{cover}}^{*})p^*, \\
\text{Nearest:} &amp;\quad (V + v_{\mathrm{cover}})p,
\end{align*}
</span></p>
<p>respectively. This will be our total cost for the nearest petrol station. For Costco, however, we need to include the membership premium <span class="math inline">M</span> which, as of 2024, is £33.60 annually. To bake this premium into the fuelling cost, I am going to multiply <span class="math inline">M</span> with an annual fuelling frequency <span class="math inline">\phi</span>. Now <span class="math inline">\phi</span> is not Costco-dependent (although it can be biased) but really user-dependent – it depends on how much you use car the car. For example, if I’m thinking of methodical use, I would put a fuelling frequency of once a week which puts <span class="math inline">\phi = 1/52</span> for the 52 weeks in the year. Adding this premium implies the total cost to be:</p>
<p><span class="math display">
\begin{align*}
\text{Costco:} &amp;\quad C^* = \phi M + (V + v_{\mathrm{cover}}^{*})p^*, \\
\text{Nearest:} &amp;\quad C = (V + v_{\mathrm{cover}})p.
\end{align*}
</span></p>
<p>We are almost there, there is one little thing to take care of. Now fuel prices changes all the time, so it’s not really right to think them as constants. So assume <span class="math inline">p</span> and <span class="math inline">p^*</span> are sampled from probability distributions <span class="math inline">\mathcal{P}(.)</span> and <span class="math inline">\mathcal{P}^*</span> respectively.</p>
<p>To answer our question, I am going to somehow bound <span class="math inline">p^*</span>. Well, this is easy.</p>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="math inline">p^*</span> criterion
</div>
</div>
<div class="callout-body-container callout-body">
<p>The total cost is bounded <span class="math inline">C^* &lt; C</span> iff <span class="math display">
p^*
&lt; \frac{(V + v_{\mathrm{cover}}) p - \phi M}{V+v^*_{\mathrm{cover}}}
= \frac{V + v_{\mathrm{cover}}}{V+v^*_{\mathrm{cover}}} p - \frac{\phi}{V+v^*_{\mathrm{cover}}} M
</span></p>
</div>
</div>
<p>The bound itself is useful (e.g.&nbsp;for algorithms), but the interpretation is much more interesting. Since <span class="math inline">d^* &gt; d</span>, we have <span class="math inline">(V + v_{\mathrm{cover}})/(V + v^*_{\mathrm{cover}}) &lt; 1</span>. The <span class="math inline">p^*</span> criterion tells us that for Costco to be worth it, it is not enough that <span class="math inline">p^* &lt; p</span>, but it needs to be less than <span class="math inline">p</span> discounted by <span class="math inline">(V + v_{\mathrm{cover}})/(V + v^*_{\mathrm{cover}})</span>, further tightened by a fraction of the premium <span class="math inline">\phi/(V + v^*_{\mathrm{cover}}) \cdot M</span>.</p>
<p>The good thing is we know how much it is being tightened by. Let’s first isolate constant-like terms. Since the premium <span class="math inline">M</span> is beyond our control, we can treat it as a constant. In fact, we can view the distance <span class="math inline">d^*</span> to the nearest Costco petrol station as fixed since there’s really one Costco station you can go to within the proximity of your house (at least in GB). This is in contrast to the distance <span class="math inline">d</span> to the nearest petrol station which can be plenty – as we have plenty of nearest petrol stations to choose from. We can also view the fuel economy <span class="math inline">e</span> as fixed as it’s not like we change cars every time we fill in the tank. This implies that we can view the term <span class="math inline">V + v^*_{\mathrm{cover}}</span> as a constant.</p>
<p>Thus the tightness of the bound is really controlled by the fuelling frequency <span class="math inline">\phi</span>. The less time you go and fill your car at Costco, the bigger <span class="math inline">\phi</span> is and hence, the bigger the effect of the premium term. This implies a tighter bound! I guess this is sort of intuitive (?) I’m trying really hard to convince myself that this is the case. And note that the multipliers on <span class="math inline">p</span> and <span class="math inline">M</span> does not add up to <span class="math inline">1</span>, i.e.&nbsp;they’re not “weights” per se, so a bigger premium effect does mean pricier total cost.</p>
</section>
<section id="some-actual-numbers" class="level2">
<h2 class="anchored" data-anchor-id="some-actual-numbers">Some actual numbers</h2>
<p>Now it’s just a matter of plugging in numbers. Here, I’ll deal with hard numbers but coding this should be straightforward. I’ll demo this using my specs, using the Esso in front of my house as my <em>nearest</em> petrol station which is 0.2 miles away. Let’s put some numbers to the constants.</p>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Annual fuelling frequency
</div>
</div>
<div class="callout-body-container callout-body">
<p>I’ll be fixing the annual fuelling frequency to <span class="math inline">\phi = 1/52</span> as before.</p>
</div>
</div>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Nearest petrol station
</div>
</div>
<div class="callout-body-container callout-body">
<p>The Esso nearest to my house is <span class="math inline">d=0.2</span> miles away and they sell petrol at <span class="math inline">p = 132.9/100</span> £/litre.</p>
</div>
</div>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Costco petrol station
</div>
</div>
<div class="callout-body-container callout-body">
<p>The nearest Costco to my house is <span class="math inline">d^*=4.8</span> miles away and they sell petrol at <span class="math inline">p = 126.9/100</span> £/litre. As of 2024, the annual Costco individual membership is priced at <span class="math inline">M = 33.60</span> pounds.</p>
</div>
</div>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Car fuel economy
</div>
</div>
<div class="callout-body-container callout-body">
<p>My car’s fuel economy is about 40 mpg. That converts to about 5.9 litres/100km or 0.059 litres/km or 0.095 litres/mile. So put <span class="math inline">e = 0.095</span> litres/mile.</p>
</div>
</div>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Petrol volume to fill
</div>
</div>
<div class="callout-body-container callout-body">
<p>Let’s say I want to fill in about <span class="math inline">V = 60</span> litres of petrol, which is about 80% into my full tank capacity.</p>
</div>
</div>
<section id="direct-compute" class="level3">
<h3 class="anchored" data-anchor-id="direct-compute">Direct compute</h3>
<p>Now we are ready to compute. The total volume we want to fill in at the petrol station is</p>
<p><span class="math display">
\begin{align*}
\text{Costco:} &amp;\quad V + v_{\mathrm{cover}}^{*} = V + 2{d^*}e = 60 + 0.9120 \text{ litres}, \\
\text{Nearest:} &amp;\quad V + v_{\mathrm{cover}} = V + 2de = 60 + 0.0019 \text{ litres}.
\end{align*}
</span></p>
<p>This gives the total fuelling cost to be</p>
<p><span class="math display">
\begin{align*}
\text{Costco:} &amp;\quad C^* = \phi M + (V + v_{\mathrm{cover}}^{*})p^* = £77.33, \\
\text{Nearest:} &amp;\quad C = (V + v_{\mathrm{cover}})p = £79.74,
\end{align*}
</span></p>
<p>and we see that fuelling at Costco today is much cheaper despite the premium and the distance!</p>
</section>
<section id="using-the-p-criterion." class="level3">
<h3 class="anchored" data-anchor-id="using-the-p-criterion.">Using the <span class="math inline">p^*</span> criterion.</h3>
<p>We could have equivalently compute the <span class="math inline">p^*</span> criterion and see that</p>
<p><span class="math display">
\frac{V + v_{\mathrm{cover}}}{V+v^*_{\mathrm{cover}}} p - \frac{\phi}{V+v^*_{\mathrm{cover}}} M = 1.29120 &gt; 1.329 = p^*.
</span></p>
<p>Indeed, the criterion is met and we did see lower Costco total cost as opposed to the cost using our nearest Esso station.</p>
</section>
</section>
<section id="so-is-costco-truly-worth-it" class="level2">
<h2 class="anchored" data-anchor-id="so-is-costco-truly-worth-it">So is Costco truly worth it?</h2>
<p>Based on today’s petrol price computation, it seems that we save <span class="math inline">\Delta := C - C^* = 2.41</span> pounds. Is it really worth it that extra time to go to Costco and save £2.41? Well, for a start, recall that <span class="math inline">p</span>, <span class="math inline">p^*</span> are random variables. This means that the savings will be a random variable as well by linearity. Now suppose we are modelling for the expectation <span class="math inline">\mathbb{E}[p]</span> and <span class="math inline">\mathbb{E}[p^*]</span> instead, what then? Well long-term savings still pile up in my opinion as the annual savings is given by <span class="math inline">\mathbb{E}[\Delta]/\phi</span>. Assuming <span class="math inline">\mathbb{E}[\Delta] = 2.41</span>, then annually we would have saved about £125. That is significant.</p>
<p>I’m buying that membership card yesterday. This is not a Costco ad.</p>
<!-- ```python
# Annual fuelling frequency
F = 1/52

# Nearest petrol station
p = 132.9 / 100  # Petrol/litre (£)
d = 0.02 # Distance to station (miles)

# Costco petrol station
M = 33.60  # Annual Costco premium (£)
p = 132.9 / 100  # Petrol/litre (£)
d = 4.8 # Distance to station (miles)

# Car fuel economy.
# 5.88036 litres/100km is my car's. Change this to yours.
E = (
    5.88036 / 100  # litres/km
    * 1.60934  # km/mile
)  # litres/mile

V = 60  # Petrol volume @ home after fuelling (litres)

v = 2*d*E
v_costco = 2*d_costco*E

v_filled = v + V
v_filled_costco = v_costco + V

# Total costs
C_costco = M*F + v_filled_costco*p_costco
C = v_filled*p
print(f"Costco: £{C_costco:,.2f}")
print(f"Nearest: £{C:,.2f}")
``` -->


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/salfaris\.github\.io");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>