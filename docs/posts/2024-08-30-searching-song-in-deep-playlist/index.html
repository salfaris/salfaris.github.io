<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.55">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Salman Faris">
<meta name="dcterms.date" content="2024-08-31">

<title>Searching for my favorite song in a deep playlist – salman faris</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta name="twitter:title" content="Searching for my favorite song in a deep playlist – salman faris">
<meta name="twitter:description" content="">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title"><strong>salman faris</strong></span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">about</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../resources.html"> 
<span class="menu-text">resources</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/salfaris/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/salfaris"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Searching for my favorite song in a deep playlist</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">combinatorics</div>
                <div class="quarto-category">spotify</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Salman Faris </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">August 31, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#painting-paths-in-a-playlist" id="toc-painting-paths-in-a-playlist" class="nav-link active" data-scroll-target="#painting-paths-in-a-playlist">Painting paths in a playlist</a></li>
  <li><a href="#answering-the-main-question" id="toc-answering-the-main-question" class="nav-link" data-scroll-target="#answering-the-main-question">Answering the main question</a></li>
  <li><a href="#what-next" id="toc-what-next" class="nav-link" data-scroll-target="#what-next">What next?</a></li>
  <li><a href="#appendix" id="toc-appendix" class="nav-link" data-scroll-target="#appendix">Appendix</a>
  <ul class="collapse">
  <li><a href="#enumerating-playlist-of-length-n" id="toc-enumerating-playlist-of-length-n" class="nav-link" data-scroll-target="#enumerating-playlist-of-length-n">Enumerating playlist of length <span class="math inline">n</span></a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<blockquote class="blockquote">
<p>TLDR; Keep your playlists small. There’s a 50% chance of finding your favourite song in less than or equal to 4 steps in a playlist of length 9. With each additional song in your playlist, you decrease the speed of finding your favourite song by roughly 10%.</p>
</blockquote>
<p>I love music. I listen to music all the time and I especially listen to music when I go running, where I would put it on shuffle mode. Now a few runs ago, I was aggressively double tapping my airpods to jump to the next song, skipping a lot of songs in the process until it reaches a song that I was keen on listening to at that moment. That’s when I started thinking, given that I started at a particular song in the playlist, can I quantify how many steps do I need to take to reach a particular favourite song in my playlist?</p>
<p><img src="./images/spotify-playlists.png" class="img-fluid"></p>
<p>Now it is important to note that modern music streaming services like Spotify do not necessarily implement naive shuffle functions which samples the next song uniformly at random. It is more likely that they implement a weighted shuffle function which samples the next music with replacement, assuming some weight on the song based on, for example, popularity of the song (global recommendation approach) or occurrence of listening to the song (a personalized approach). For the sake of this problem, however, we will assume that the songs in the playlist are shuffled uniformly at random.</p>
<p>There are many ways to approach this problem (which is the beauty of this problem). For example, one can form a <a href="https://en.wikipedia.org/wiki/Complete_graph">complete digraph</a> for the songs in the playlist, remove the directed path from your favourite song to any other node (but keep the inverse so that your favourite song is a sink) and then count the number of all possible paths between any node (song) and the target favourite song. Note that this is different to finding a shortest path which we have Dijsktra’s algorithm for. That algorithm runs in <span class="math inline">O\left(|E| + |V| \log |V| \right)</span> time where <span class="math inline">E</span> is the multiset of edges and <span class="math inline">V</span> the set of nodes. Rather, the problem of finding the number of paths is much harder and would not have an algorithm that enjoy such speeds.</p>
<p>Instead of the graph approach, I will go down the dark hole known as combinatorics. The downside is that the setup will be less natural and will require some level of abstraction. The upside, however, is that once everything is set up nicely, solving the problem essentially amounts to careful counting. Let’s start seeing an example on how we can do this.</p>
<section id="painting-paths-in-a-playlist" class="level2">
<h2 class="anchored" data-anchor-id="painting-paths-in-a-playlist">Painting paths in a playlist</h2>
<p>Suppose a playlist contains three songs <span class="math inline">s_1, s_2, s_T</span>. Let’s ask the most basic question of <em>how many paths can I reach the target song <span class="math inline">s_T</span></em>? Now the answer is not <span class="math inline">3!=6</span> because you can reach <span class="math inline">s_T</span> without visiting all the other songs in the playlist. For example, you can reach <span class="math inline">s_T</span> via the route <span class="math inline">s_1 \to s_T</span> or <span class="math inline">s_2 \to s_T</span> respectively. In total, you can reach <span class="math inline">s_T</span> in 5 different ways. These are:</p>
<ol type="1">
<li><span class="math inline">s_T \to s_T</span></li>
<li><span class="math inline">s_1 \to s_T</span></li>
<li><span class="math inline">s_2 \to s_T</span></li>
<li><span class="math inline">s_1 \to s_2 \to s_T</span></li>
<li><span class="math inline">s_2 \to s_1 \to s_T</span></li>
</ol>
<p>where the first path <span class="math inline">s_T \to s_T</span> is the tautological path of starting and ending at <span class="math inline">s_T</span>.</p>
<p>How about if the playlist contain four songs <span class="math inline">s_1, s_2, s_3, s_T</span>, how many paths can I reach the target song <span class="math inline">s_T</span>? You should be convinced by now that the answer is not <span class="math inline">4!=24</span>, but how many? The answer is that there are 16 paths in total. For your sanity, I will enumerate this long list below:</p>
<ol type="1">
<li><span class="math inline">s_T \to s_T</span></li>
<li><span class="math inline">s_1 \to s_T</span></li>
<li><span class="math inline">s_2 \to s_T</span></li>
<li><span class="math inline">s_3 \to s_T</span></li>
<li><span class="math inline">s_1 \to s_2 \to s_T</span></li>
<li><span class="math inline">s_2 \to s_1 \to s_T</span></li>
<li><span class="math inline">s_3 \to s_2 \to s_T</span></li>
<li><span class="math inline">s_2 \to s_3 \to s_T</span></li>
<li><span class="math inline">s_1 \to s_3 \to s_T</span></li>
<li><span class="math inline">s_3 \to s_1 \to s_T</span></li>
<li><span class="math inline">s_1 \to s_2 \to s_3 \to s_T</span></li>
<li><span class="math inline">s_2 \to s_1 \to s_3 \to s_T</span></li>
<li><span class="math inline">s_3 \to s_2 \to s_1 \to s_T</span></li>
<li><span class="math inline">s_2 \to s_3 \to s_1 \to s_T</span></li>
<li><span class="math inline">s_1 \to s_3 \to s_2 \to s_T</span></li>
<li><span class="math inline">s_3 \to s_1 \to s_2 \to s_T</span>.</li>
</ol>
<p>Now you should start to see a pattern. In both cases where the playlist is of length three and four, we observe that the target song <span class="math inline">s_T</span> remains fixed and the only thing that changes is the order of the songs prior to <span class="math inline">s_T</span>. Further, the number of songs that are reordered is progressively unconstrained to acknowledge that you can reach the target song in an increasing number of steps. Thus, the number of paths to reach the target song <span class="math inline">s_T</span> is just a sum of <span class="math inline">k</span>-permutations of <span class="math inline">n-1</span> songs where <span class="math inline">k</span> is the number of steps allowed to reach <span class="math inline">s_T</span> and <span class="math inline">n</span> is the length of the playlist. This sum is done from <span class="math inline">0</span>, which represents the tautological path <span class="math inline">s_T \to s_T</span>, up to <span class="math inline">n-1</span> which represents a permutation of the path <span class="math inline">s_1 \to s_2 \to \cdots \to s_{n-1} \to s_T</span>. This argument essentially is a proof of the following result.</p>
<hr>
<div id="prp-paths1" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 1 (Number of paths given playlist)</strong></span> The number of paths to reach the target song <span class="math inline">s_T</span> in a playlist <span class="math inline">\mathcal{P}</span> of length <span class="math inline">n</span> is given by: <span class="math display">N(n; \mathcal{P}) = \sum_{j=0}^{n-1} P(n-1, j).</span></p>
<p>where <span class="math inline">P(m, k)</span> is the <span class="math inline">k</span>-permutation of <span class="math inline">m</span> objects.</p>
</div>
<hr>
<p>In the case of <span class="math inline">n=4</span> that we have just enumerated above, the number of steps is given by:</p>
<p><span class="math display">
N(4) = P(3, 0) + P(3, 1) + P(3, 2) + P(3, 3) = 1 + 3 + 6 + 6 = 16
</span></p>
<p>which agrees with our brute-force enumeration. Similarly, you can check that <span class="math inline">N(3) = 5</span> as we have enumerated before.</p>
<p>So this is a good result, but it has not answer our main question:</p>
<blockquote class="blockquote">
<p>Given a song <span class="math inline">s</span> in playlist <span class="math inline">\mathcal{P}</span>, how many ways can you reach your favourite song <span class="math inline">s_T \in \mathcal{P}</span> in less than or equal to <span class="math inline">t \in \mathbb{Z}^+</span> steps?</p>
</blockquote>
<p>It has, however, answered the easier question:</p>
<blockquote class="blockquote">
<p>Given a playlist <span class="math inline">\mathcal{P}</span>, how many ways can you reach your favourite song <span class="math inline">s_T \in \mathcal{P}</span> in less than or equal to <span class="math inline">t \in \mathbb{Z}^+</span> steps?</p>
</blockquote>
<p>This question is answered by using <a href="#prp-paths1" class="quarto-xref">Proposition&nbsp;1</a> and simply truncating the summation at <span class="math inline">t \leq n-1</span>.</p>
<p>The difference between the main question and this easier question is that the former essentially wants <span class="math inline">N | s, \mathcal{P}</span> whereas what we have at the moment gives <span class="math inline">N | \mathcal{P}</span>. So let’s move towards a solution, suppose we start at a song <span class="math inline">s \in \mathcal{P}</span>, what then?</p>
</section>
<section id="answering-the-main-question" class="level2">
<h2 class="anchored" data-anchor-id="answering-the-main-question">Answering the main question</h2>
<p>I have been using the term <em>playlist</em> quite loosely throughout this article so let’s make it concrete. A playlist <span class="math inline">\mathcal{P}</span> of length <span class="math inline">n</span> is simply a finite set of songs <span class="math inline">\{ s_1, s_2, \ldots, s_{n-1}, s_T\}</span>. It does not assume any ordering, and our logic does not assume ordering unless mentioned otherwise. This definition aligns with what we had before and so the result(s) remain.</p>
<p>As per <a href="#prp-paths1" class="quarto-xref">Proposition&nbsp;1</a>, we know that <span class="math inline">N(4) = 16</span> and reaching the target song in less than or equal to <span class="math inline">k \leq n-1</span> steps is given by <span class="math inline">\sum_{j=0}^{k} P(n-1, j)</span>. These makes no assumption on where we start the path at. Suppose now you start at song <span class="math inline">s_3</span> in the playlist. How many paths can you take take to reach your target song <span class="math inline">s_T</span>? Let’s start enumerating all the possible paths to reach <span class="math inline">s_T</span> again, but this time we highlight how many steps it takes to reach <span class="math inline">s_T</span> from <span class="math inline">s_3</span>.</p>
<ol type="1">
<li><span class="math inline">s_T \to s_T</span> <strong>(impossible)</strong></li>
<li><span class="math inline">s_1 \to s_T</span> <strong>(impossible)</strong></li>
<li><span class="math inline">s_2 \to s_T</span> <strong>(impossible)</strong></li>
<li><span class="math inline">s_3 \to s_T</span> <strong>(1)</strong></li>
<li><span class="math inline">s_1 \to s_2 \to s_T</span> <strong>(impossible)</strong></li>
<li><span class="math inline">s_2 \to s_1 \to s_T</span> <strong>(impossible)</strong></li>
<li><span class="math inline">s_3 \to s_2 \to s_T</span> <strong>(2)</strong></li>
<li><span class="math inline">s_2 \to s_3 \to s_T</span> <strong>(1)</strong></li>
<li><span class="math inline">s_1 \to s_3 \to s_T</span> <strong>(1)</strong></li>
<li><span class="math inline">s_3 \to s_1 \to s_T</span> <strong>(2)</strong></li>
<li><span class="math inline">s_1 \to s_2 \to s_3 \to s_T</span> <strong>(1)</strong></li>
<li><span class="math inline">s_2 \to s_1 \to s_3 \to s_T</span> <strong>(1)</strong></li>
<li><span class="math inline">s_3 \to s_2 \to s_1 \to s_T</span> <strong>(3)</strong></li>
<li><span class="math inline">s_2 \to s_3 \to s_1 \to s_T</span> <strong>(2)</strong></li>
<li><span class="math inline">s_1 \to s_3 \to s_2 \to s_T</span> <strong>(2)</strong></li>
<li><span class="math inline">s_3 \to s_1 \to s_2 \to s_T</span> <strong>(3)</strong>.</li>
</ol>
<p>To argue easier, we first make the following definition.</p>
<hr>
<div id="def-tpath" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1 (t-path)</strong></span> Let <span class="math inline">\mathcal{P}</span> be a playlist of length <span class="math inline">n</span>. A <span class="math inline">t</span>-path from <span class="math inline">s_j \in \mathcal{P}</span> is a path that starts at <span class="math inline">s_j</span> and ends at <span class="math inline">s_T \in \mathcal{P}</span> in <span class="math inline">t \in \mathbb{Z}^+</span> steps.</p>
<p>It is trivially non-unique as we have seen. So we denote the number of <span class="math inline">t</span>-paths from <span class="math inline">s_j</span> by <span class="math inline">N_t(n; s_j)</span>. If the dependence on <span class="math inline">s_j</span> is obvious, we simply write <span class="math inline">N_t(n)</span>.</p>
<p>Here are some examples. <span class="math inline">s_1 \to s_T</span> is a 1-path from <span class="math inline">s_1</span>. Another example is that <span class="math inline">s_3 \to s_4 \to s_1 \to s_T</span> is a 2-path from <span class="math inline">s_4</span> and a 1-path from <span class="math inline">s_1</span>.</p>
</div>
<hr>
<p>Back to our enumeration of the playlist of length <span class="math inline">4</span>, we observe firstly that there are some impossible paths where <span class="math inline">s_3</span> is not visited at all. Then you have five 1-paths to reach <span class="math inline">s_T</span> from <span class="math inline">s_3</span>, four 2-paths and two 3-paths.</p>
<p>Just focusing on 1-paths here, it is easy to see that the number of 1-paths to reach <span class="math inline">s_T</span> from <span class="math inline">s_3</span> is given by <span class="math inline">N(n-1)</span> because we can “group” <span class="math inline">s_3 \to s_T</span> together and treat it as a single end point <span class="math inline">s_T'</span>. It is also easy to see that the number of 3-paths is essentially a permutation on songs that are left, which in this case is <span class="math inline">2! = 2</span>. It is tempting now to say that the case of 2-paths is simply <span class="math inline">N(n-1) - 1</span> since we are discarding the unique <span class="math inline">s_3 \to s_T</span> case which exists only for 1-paths and that everything else is just a permutation of the remaining songs; and you are not wrong to think so as we shall see! The problem is that it does not give a strong explanation for what a general pattern would be.</p>
<p>So let’s look at a playlist of length <span class="math inline">n=5</span> and count each <span class="math inline">t</span>-path from <span class="math inline">s_4</span>. At this point enumeration of the playlist can get a bit crazy as we know by <a href="#prp-paths1" class="quarto-xref">Proposition&nbsp;1</a> that there are <span class="math inline">N(5) = 65</span> paths to reach <span class="math inline">s_T</span> from <span class="math inline">s_4</span>. I highly recommend you enumerate these paths by writing code (I’ve provided a fugly python code to do this in the appendix. See <a href="#lst-enum" class="quarto-xref">Listing&nbsp;1</a>). Now if we focus on each <span class="math inline">t</span>-paths, we see that there are</p>
<ol type="1">
<li>16 counts of 1-paths,</li>
<li>15 counts of 2-paths,</li>
<li>12 counts of 3-paths,</li>
<li>6 counts of 4-paths.</li>
</ol>
<p>As we have observed before, the number of 1-paths is indeed <span class="math inline">N(n-1) = N(4) = 16</span>. Discard the unique <span class="math inline">s_4 \to s_T</span> path and we have 15 count of 2-paths. And that the number of 4-paths is just a permutation on songs that are left giving us <span class="math inline">(5-2)! = 3! = 6</span>. So how do we explain the 12 counts of 3-paths? Now a 3-path from <span class="math inline">s_4</span> would look like the following</p>
<p><span class="math display">
\textcolor{blue}{\rule{1.8ex}{1.8ex}} \to s_4 \to \rule{1.8ex}{1.8ex} \to \rule{1.8ex}{1.8ex} \to s_T,
</span></p>
<p>where the <span class="math inline">\textcolor{blue}{\rule{1.8ex}{1.8ex}}, \rule{1.8ex}{1.8ex}</span> are placeholders for other songs. Let’s start counting and consider parity. If we assume <span class="math inline">\textcolor{blue}{\rule{1.8ex}{1.8ex}}</span> is null, i.e., we start at <span class="math inline">s_4</span>, then there are <span class="math inline">P(3, 2)</span> possible ways to fill in <span class="math inline">\rule{1.8ex}{1.8ex}</span>, and hence, <span class="math inline">P(3, 2)</span> number of steps to reach <span class="math inline">s_T</span>. On the other hand, if we assume <span class="math inline">\textcolor{blue}{\rule{1.8ex}{1.8ex}}</span> is not null, i.e., the path starts at one of <span class="math inline">s_1, s_2, s_3</span>, then there are <span class="math inline">P(3, 3)</span> possible ways to fill in <span class="math inline">\textcolor{blue}{\rule{1.8ex}{1.8ex}}, \rule{1.8ex}{1.8ex}</span>. So in total, the number of 3-paths is <span class="math inline">P(3, 2) + P(3, 3) = 12</span> which is what we observed in the enumeration!</p>
<p>In fact, we can run this same argument for all the other <span class="math inline">t</span>-paths as well. For a 4-path from <span class="math inline">s_4</span>, we would have the following sequence</p>
<p><span class="math display">
s_4 \to \rule{1.8ex}{1.8ex} \to \rule{1.8ex}{1.8ex} \to \rule{1.8ex}{1.8ex} \to s_T.
</span></p>
<p>In this case, it is trivial to see that there are <span class="math inline">P(3, 3) = 6</span> ways to fill in the <span class="math inline">\rule{1.8ex}{1.8ex}</span> boxes.</p>
<p>For 2-paths, we have the following sequence</p>
<p><span class="math display">
\textcolor{green}{\rule{1.8ex}{1.8ex}} \to \textcolor{blue}{\rule{1.8ex}{1.8ex}} \to s_4 \to \rule{1.8ex}{1.8ex} \to s_T.
</span></p>
<p>If we assume both <span class="math inline">\textcolor{green}{\rule{1.8ex}{1.8ex}}, \textcolor{blue}{\rule{1.8ex}{1.8ex}}</span> to be null, then there are <span class="math inline">P(3, 1)</span> possible ways to fill in <span class="math inline">\textcolor{black}{\rule{1.8ex}{1.8ex}}</span>. The case where <span class="math inline">\textcolor{blue}{\rule{1.8ex}{1.8ex}}</span> is null but <span class="math inline">\textcolor{green}{\rule{1.8ex}{1.8ex}}</span> is not null is impossible, so suppose only <span class="math inline">\textcolor{green}{\rule{1.8ex}{1.8ex}}</span> is null. Then there are <span class="math inline">P(3, 2)</span> possible ways to fill in <span class="math inline">\textcolor{blue}{\rule{1.8ex}{1.8ex}}, \textcolor{black}{\rule{1.8ex}{1.8ex}}</span> with songs. And finally if <span class="math inline">\textcolor{green}{\rule{1.8ex}{1.8ex}}</span> not null, then there are <span class="math inline">P(3, 3)</span> ways to fill in <span class="math inline">\textcolor{green}{\rule{1.8ex}{1.8ex}}, \textcolor{blue}{\rule{1.8ex}{1.8ex}}, \textcolor{black}{\rule{1.8ex}{1.8ex}}</span>. Thus in total, we have <span class="math inline">P(3, 1) + P(3, 2) + P(3, 3) = 15</span> paths to reach <span class="math inline">s_T</span>.</p>
<p>The 1-path case is just considering an additional box <span class="math inline">\textcolor{red}{\rule{1.8ex}{1.8ex}}</span> that can take a null value and running the same argument should lead you to 16 steps in total. It should not be difficult to see how we can generalize this pattern to arbitrary playlists of length <span class="math inline">n</span> so I leave the proof as an exercise for you to do.</p>
<p>Such a proof would yield the following result.</p>
<hr>
<div id="thm-tpaths" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 (Number of t-paths)</strong></span> Let <span class="math inline">\mathcal{P}</span> be a playlist of length <span class="math inline">n</span>. Given a starting song <span class="math inline">s \in \mathcal{P}</span> and a target song <span class="math inline">s_T \in \mathcal{P}</span>, the number of <span class="math inline">t</span>-paths from <span class="math inline">s</span> to <span class="math inline">s_T</span> is given by:</p>
<p><span class="math display">
% N_{\text{t-path}}(t, n; s, s_T) = \sum_{j=0}^{n-1-t} P(n-2, n-2-j).
N_{t}(n) = \sum_{j=0}^{n-1-t} P(n-2, n-2-j).
</span></p>
</div>
<hr>
<p>This is a great result as it gives us a way to compute the number of paths to reach a song in a playlist of length <span class="math inline">n</span> in exactly <span class="math inline">t</span> steps. As a consequence, we can now compute the number of paths to reach a song in a playlist of length <span class="math inline">n</span> in less than or equal to <span class="math inline">t</span> steps.</p>
<hr>
<div id="cor-tpaths" class="theorem corollary">
<p><span class="theorem-title"><strong>Corollary 1 (Number of paths to reach favourite song in <span class="math inline">\leq</span> t steps)</strong></span> Let <span class="math inline">\mathcal{P}</span> be a playlist of length <span class="math inline">n</span>. Given a starting song <span class="math inline">s \in \mathcal{P}</span> and a target song <span class="math inline">s_T \in \mathcal{P}</span>, the number of paths to reach <span class="math inline">s_T</span> in less than or equal <span class="math inline">t \in \mathbb{Z}^+</span> steps is given by:</p>
<p><span class="math display">
N_{\leq t}(n) = \sum_{\ell=1}^{t} N_{\ell}(n).
</span></p>
</div>
<hr>
<p>What’s great about <a href="#cor-tpaths" class="quarto-xref">Corollary&nbsp;1</a>? Well it gives a satisfying answer to our main question of</p>
<blockquote class="blockquote">
<p>Given a song <span class="math inline">s</span> in playlist <span class="math inline">\mathcal{P}</span>, how many ways can you reach your favourite song <span class="math inline">s_T \in \mathcal{P}</span> in less than or equal to <span class="math inline">t \in \mathbb{Z}^+</span> steps?</p>
</blockquote>
<p>which is all that we wanted. To see this in practice, fix <span class="math inline">t=4</span> to consider the number of paths to reach your favourite song in less than or equal to 4 steps. Then we look at <span class="math inline">N_{\leq t}</span> with varying <span class="math inline">n</span> in the range <span class="math inline">5 \leq n \leq 14</span>. We will also consider the probability of reaching your favourite song in less than or equal to <span class="math inline">t</span> steps by computing <span class="math inline">N_{\leq t}/N(n)</span>. The numbers are tabulated below.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 2%">
<col style="width: 26%">
<col style="width: 40%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="header">
<th><span class="math inline">n</span></th>
<th><span class="math inline">N_{\leq t}</span></th>
<th><span class="math inline">\lfloor \log N_{\leq t}\rfloor</span></th>
<th><span class="math inline">N_{\leq t}/N(n)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>5</td>
<td>49</td>
<td>1</td>
<td>0.75</td>
</tr>
<tr class="even">
<td>6</td>
<td>237</td>
<td>2</td>
<td>0.73</td>
</tr>
<tr class="odd">
<td>7</td>
<td>1271</td>
<td>3</td>
<td>0.65</td>
</tr>
<tr class="even">
<td>8</td>
<td>7783</td>
<td>3</td>
<td>0.57</td>
</tr>
<tr class="odd">
<td>9</td>
<td>54741</td>
<td>4</td>
<td>0.50</td>
</tr>
<tr class="even">
<td>10</td>
<td>438329</td>
<td>5</td>
<td>0.44</td>
</tr>
<tr class="odd">
<td>11</td>
<td>3945547</td>
<td>6</td>
<td>0.40</td>
</tr>
<tr class="even">
<td>12</td>
<td>39456291</td>
<td>7</td>
<td>0.36</td>
</tr>
<tr class="odd">
<td>13</td>
<td>434020313</td>
<td>8</td>
<td>0.33</td>
</tr>
<tr class="even">
<td>14</td>
<td>5208245221</td>
<td>9</td>
<td>0.31</td>
</tr>
</tbody>
</table>
<p>It is not suprising to see that with increasing number of playlist length <span class="math inline">n</span>, the number of paths <span class="math inline">N_{\leq t}</span> increases dramatically. In fact, as we have computed with <span class="math inline">\lfloor \log N_{\leq t} \rfloor</span>, the order of magnitude increases roughly by one at every increasing length <span class="math inline">n</span>. The probability, however, does not decrease as dramatically, so you still have a good chance of finding your favourite songs with ease.</p>
<p>Today, I have a playlist with 53 songs. The number of possible paths to reach my current favourite song in this playlist in less than or equal to <span class="math inline">t=4</span> steps given an abitrary starting song is</p>
<p><span class="math display">
16865511683372560412495381946812946399349813999270471596889656524800 \sim 10^{67}
</span></p>
<p>paths which is on the order of 67. This is an exorbitantly huge number with 67 zeros. If we were to compute <span class="math inline">N_{\leq t}/N(n)</span>, we get 7.7% which is honestly not too bad. But still… an 8% chance of finding my favourite song is quite low. Moral of the story? Try to make your playlists small.</p>
</section>
<section id="what-next" class="level2">
<h2 class="anchored" data-anchor-id="what-next">What next?</h2>
<p>Here are some key directions we can take to explore.</p>
<ol type="1">
<li>What if instead of a single target favourite song <span class="math inline">s_T</span>, we have a set of target songs <span class="math inline">\{s_{T_1}, s_{T_2}, ...\}</span>. How will the analysis differ when we start at any arbitrary song? This seems easy… I think.</li>
<li>Similarly, what if instead of a single starting song <span class="math inline">s</span>, we have a set of arbitrary starting songs <span class="math inline">\{s_1, s_2, ...\}</span>. How will the number of paths change?</li>
<li>Do a precise analysis on the order of growth in the number of paths. If you divide <span class="math inline">N_{\leq t}</span> for <span class="math inline">n</span> with <span class="math inline">n-1</span> successively, you will see that the growth is factorial. This is kind of expected but can you prove it? It is easy to see that the growth in the total number of paths is factorial by using <a href="#prp-paths1" class="quarto-xref">Proposition&nbsp;1</a>, but how about for paths up to <span class="math inline">t</span> steps?</li>
<li>Do a precise analysis on <span class="math inline">N_{\leq t}/N(n)</span>. Seems like there’s approximately a ~90% drop for the numbers that we have tabulated as <span class="math inline">n</span> increases. Finding a bound would be excellent.</li>
<li>I’m pretty sure we can try solving this problem using group theory.</li>
<li>Consider weighted shuffle on playlists now, how would you solve the same problem? Maybe a graph approach is inevitable?</li>
</ol>
</section>
<section id="appendix" class="level2">
<h2 class="anchored" data-anchor-id="appendix">Appendix</h2>
<section id="enumerating-playlist-of-length-n" class="level3">
<h3 class="anchored" data-anchor-id="enumerating-playlist-of-length-n">Enumerating playlist of length <span class="math inline">n</span></h3>
<p>The code below enumerates a playlist of length <span class="math inline">n</span> but it is highly inefficient. A back of the envelope estimate gives me a rough <span class="math inline">O(n!)</span> time complexity. Can you do better?</p>
<div id="lst-enum" class="python listing quarto-float quarto-figure quarto-figure-left anchored">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst" id="lst-enum-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listing&nbsp;1: Enumerate playlist of length <span class="math inline">n=4</span>
</figcaption>
<div aria-describedby="lst-enum-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode" id="lst-enum"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="lst-enum-1"><a href="#lst-enum-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> permutations</span>
<span id="lst-enum-2"><a href="#lst-enum-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-enum-3"><a href="#lst-enum-3" aria-hidden="true" tabindex="-1"></a>NULL <span class="op">=</span> <span class="dv">0</span></span>
<span id="lst-enum-4"><a href="#lst-enum-4" aria-hidden="true" tabindex="-1"></a>E <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="lst-enum-5"><a href="#lst-enum-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-enum-6"><a href="#lst-enum-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-enum-7"><a href="#lst-enum-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> enum(seq: <span class="bu">list</span>[<span class="bu">int</span>]) <span class="op">-&gt;</span> <span class="bu">set</span>[<span class="bu">tuple</span>[<span class="bu">int</span>, ...]]:</span>
<span id="lst-enum-8"><a href="#lst-enum-8" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(seq)</span>
<span id="lst-enum-9"><a href="#lst-enum-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-enum-10"><a href="#lst-enum-10" aria-hidden="true" tabindex="-1"></a>    pool <span class="op">=</span> <span class="bu">set</span>(<span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="lst-enum-11"><a href="#lst-enum-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-enum-12"><a href="#lst-enum-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find indexes where values are not empty.</span></span>
<span id="lst-enum-13"><a href="#lst-enum-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Since we only care about permutations, values are unique at each index (except</span></span>
<span id="lst-enum-14"><a href="#lst-enum-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># for the NULL value). So remove encountered filled values from the permutation</span></span>
<span id="lst-enum-15"><a href="#lst-enum-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># pool.</span></span>
<span id="lst-enum-16"><a href="#lst-enum-16" aria-hidden="true" tabindex="-1"></a>    filled_idxs: <span class="bu">list</span>[<span class="bu">int</span>] <span class="op">=</span> []</span>
<span id="lst-enum-17"><a href="#lst-enum-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> idx, v <span class="kw">in</span> <span class="bu">enumerate</span>(seq):</span>
<span id="lst-enum-18"><a href="#lst-enum-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">!=</span> E:</span>
<span id="lst-enum-19"><a href="#lst-enum-19" aria-hidden="true" tabindex="-1"></a>            filled_idxs.append(idx)</span>
<span id="lst-enum-20"><a href="#lst-enum-20" aria-hidden="true" tabindex="-1"></a>            pool.remove(v)</span>
<span id="lst-enum-21"><a href="#lst-enum-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-enum-22"><a href="#lst-enum-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Make pool into a list because we may append &gt;=1 NULLs to it.</span></span>
<span id="lst-enum-23"><a href="#lst-enum-23" aria-hidden="true" tabindex="-1"></a>    pool <span class="op">=</span> <span class="bu">list</span>(pool)</span>
<span id="lst-enum-24"><a href="#lst-enum-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The least index of filled values determine the number of NULLs possible for</span></span>
<span id="lst-enum-25"><a href="#lst-enum-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># the permutations.</span></span>
<span id="lst-enum-26"><a href="#lst-enum-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(filled_idxs)):</span>
<span id="lst-enum-27"><a href="#lst-enum-27" aria-hidden="true" tabindex="-1"></a>        pool.append(NULL)</span>
<span id="lst-enum-28"><a href="#lst-enum-28" aria-hidden="true" tabindex="-1"></a>    all_perm <span class="op">=</span> <span class="bu">list</span>(permutations(pool, r<span class="op">=</span>(n <span class="op">-</span> <span class="bu">len</span>(filled_idxs))))</span>
<span id="lst-enum-29"><a href="#lst-enum-29" aria-hidden="true" tabindex="-1"></a>    all_perm <span class="op">=</span> <span class="bu">set</span>(all_perm)  <span class="co"># remove dups</span></span>
<span id="lst-enum-30"><a href="#lst-enum-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-enum-31"><a href="#lst-enum-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-enum-32"><a href="#lst-enum-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find invalid NULL configurations such as (NULL, 1, NULL, ...). NULLs cannot</span></span>
<span id="lst-enum-33"><a href="#lst-enum-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># appear after valid positive integer.</span></span>
<span id="lst-enum-34"><a href="#lst-enum-34" aria-hidden="true" tabindex="-1"></a>    bad_seqs <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="lst-enum-35"><a href="#lst-enum-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> p <span class="kw">in</span> all_perm:</span>
<span id="lst-enum-36"><a href="#lst-enum-36" aria-hidden="true" tabindex="-1"></a>        num_found <span class="op">=</span> <span class="va">False</span></span>
<span id="lst-enum-37"><a href="#lst-enum-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> p:</span>
<span id="lst-enum-38"><a href="#lst-enum-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">!=</span> NULL:</span>
<span id="lst-enum-39"><a href="#lst-enum-39" aria-hidden="true" tabindex="-1"></a>                num_found <span class="op">=</span> <span class="va">True</span></span>
<span id="lst-enum-40"><a href="#lst-enum-40" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="lst-enum-41"><a href="#lst-enum-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> num_found <span class="kw">and</span> i <span class="op">==</span> NULL:</span>
<span id="lst-enum-42"><a href="#lst-enum-42" aria-hidden="true" tabindex="-1"></a>                bad_seqs.add(p)</span>
<span id="lst-enum-43"><a href="#lst-enum-43" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="lst-enum-44"><a href="#lst-enum-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-enum-45"><a href="#lst-enum-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sucks this is python and you have to do something like this</span></span>
<span id="lst-enum-46"><a href="#lst-enum-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="bu">isinstance</span>(all_perm, <span class="bu">set</span>), <span class="st">"`all_perm` is not a set."</span></span>
<span id="lst-enum-47"><a href="#lst-enum-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-enum-48"><a href="#lst-enum-48" aria-hidden="true" tabindex="-1"></a>    good_seqs <span class="op">=</span> all_perm <span class="op">-</span> bad_seqs</span>
<span id="lst-enum-49"><a href="#lst-enum-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> good_seqs</span>
<span id="lst-enum-50"><a href="#lst-enum-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-enum-51"><a href="#lst-enum-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-enum-52"><a href="#lst-enum-52" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="lst-enum-53"><a href="#lst-enum-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-enum-54"><a href="#lst-enum-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> generate_new_seq(n: <span class="bu">int</span>):</span>
<span id="lst-enum-55"><a href="#lst-enum-55" aria-hidden="true" tabindex="-1"></a>        new_seq <span class="op">=</span> []</span>
<span id="lst-enum-56"><a href="#lst-enum-56" aria-hidden="true" tabindex="-1"></a>        init <span class="op">=</span> [E] <span class="op">*</span> n</span>
<span id="lst-enum-57"><a href="#lst-enum-57" aria-hidden="true" tabindex="-1"></a>        init[<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> n</span>
<span id="lst-enum-58"><a href="#lst-enum-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">2</span>, E, E):</span>
<span id="lst-enum-59"><a href="#lst-enum-59" aria-hidden="true" tabindex="-1"></a>            init[i] <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span></span>
<span id="lst-enum-60"><a href="#lst-enum-60" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">!=</span> n <span class="op">-</span> <span class="dv">2</span>:</span>
<span id="lst-enum-61"><a href="#lst-enum-61" aria-hidden="true" tabindex="-1"></a>                init[i <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> E</span>
<span id="lst-enum-62"><a href="#lst-enum-62" aria-hidden="true" tabindex="-1"></a>            new_seq.append(init.copy())</span>
<span id="lst-enum-63"><a href="#lst-enum-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> new_seq</span>
<span id="lst-enum-64"><a href="#lst-enum-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-enum-65"><a href="#lst-enum-65" aria-hidden="true" tabindex="-1"></a>    seqs <span class="op">=</span> generate_new_seq(<span class="dv">5</span>)</span>
<span id="lst-enum-66"><a href="#lst-enum-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-enum-67"><a href="#lst-enum-67" aria-hidden="true" tabindex="-1"></a>    full_enumeration <span class="op">=</span> []</span>
<span id="lst-enum-68"><a href="#lst-enum-68" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> seq <span class="kw">in</span> seqs:</span>
<span id="lst-enum-69"><a href="#lst-enum-69" aria-hidden="true" tabindex="-1"></a>        valid_perms <span class="op">=</span> enum(seq)</span>
<span id="lst-enum-70"><a href="#lst-enum-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> perm_seq <span class="kw">in</span> valid_perms:</span>
<span id="lst-enum-71"><a href="#lst-enum-71" aria-hidden="true" tabindex="-1"></a>            seq2 <span class="op">=</span> seq.copy()</span>
<span id="lst-enum-72"><a href="#lst-enum-72" aria-hidden="true" tabindex="-1"></a>            idx <span class="op">=</span> <span class="dv">0</span></span>
<span id="lst-enum-73"><a href="#lst-enum-73" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> perm_seq:</span>
<span id="lst-enum-74"><a href="#lst-enum-74" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> seq2[idx] <span class="op">!=</span> E:</span>
<span id="lst-enum-75"><a href="#lst-enum-75" aria-hidden="true" tabindex="-1"></a>                    idx <span class="op">+=</span> <span class="dv">1</span></span>
<span id="lst-enum-76"><a href="#lst-enum-76" aria-hidden="true" tabindex="-1"></a>                seq2[idx] <span class="op">=</span> i</span>
<span id="lst-enum-77"><a href="#lst-enum-77" aria-hidden="true" tabindex="-1"></a>            full_enumeration.append(seq2)</span>
<span id="lst-enum-78"><a href="#lst-enum-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-enum-79"><a href="#lst-enum-79" aria-hidden="true" tabindex="-1"></a>    full_enumeration.sort()</span>
<span id="lst-enum-80"><a href="#lst-enum-80" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="bu">len</span>(full_enumeration)</span>
<span id="lst-enum-81"><a href="#lst-enum-81" aria-hidden="true" tabindex="-1"></a>    warn_out <span class="op">=</span> (</span>
<span id="lst-enum-82"><a href="#lst-enum-82" aria-hidden="true" tabindex="-1"></a>        <span class="st">"WARNING: Note that we use '0' as NULL pointers in the following enumeration."</span></span>
<span id="lst-enum-83"><a href="#lst-enum-83" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="lst-enum-84"><a href="#lst-enum-84" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"-"</span> <span class="op">*</span> <span class="bu">len</span>(warn_out))</span>
<span id="lst-enum-85"><a href="#lst-enum-85" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(warn_out)</span>
<span id="lst-enum-86"><a href="#lst-enum-86" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"-"</span> <span class="op">*</span> <span class="bu">len</span>(warn_out))</span>
<span id="lst-enum-87"><a href="#lst-enum-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> e <span class="kw">in</span> full_enumeration:</span>
<span id="lst-enum-88"><a href="#lst-enum-88" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(e)</span>
<span id="lst-enum-89"><a href="#lst-enum-89" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>()</span>
<span id="lst-enum-90"><a href="#lst-enum-90" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"N_t(</span><span class="sc">{</span><span class="bu">len</span>(seq)<span class="sc">}</span><span class="ss">) = </span><span class="sc">{</span>N<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</figure>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/salfaris\.github\.io");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>